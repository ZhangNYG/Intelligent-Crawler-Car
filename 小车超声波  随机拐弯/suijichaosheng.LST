C51 COMPILER V9.01   SUIJICHAOSHENG                                                        08/25/2013 18:01:54 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE SUIJICHAOSHENG
OBJECT MODULE PLACED IN suijichaosheng.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE suijichaosheng.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*********************************************************************************************************
             -**/
   2          //hc-sr04 超声波测距模块 DEMO 程序                                      在实验中涉及到了全局变量的问题     并解决      以后       少用全局变量
   3          //晶振：11。0592
   4          //
   5          //接线：模块TRIG/TX接 P2.7     ECH0/RX 接P2.6
   6          //数码管：共阳数码管P0接数据口,P2.0 P2.1 P2.2,,P2.3接选通数码管
   7          //两个电机驱动     in1接P1.1  in2接P1.2  in3接P1.3  in4接P1.4 
   8          /*********************************************************************************************************
             -**/            
   9          #include <reg52.H>              //器件配置文件
  10          #include <intrins.h>
  11          #include <stdlib.h>     //随机数头文件  srand  rand 
  12          
  13                                   
  14          unsigned int  time=0;
  15          unsigned int  timer=0;
  16          unsigned char posit=0;
  17          unsigned long S=0;
  18          bit      flag =0;
  19          sbit  RX  =P2^6;
  20          sbit  TX  =P2^7;
  21          //sbit  ena  =P3^0;
  22          //sbit  enb  =P3^2;
  23          sbit p2_0 = P2^0;
  24          sbit p2_1 = P2^1;
  25          sbit p2_2 = P2^2;
  26          sbit p2_3 = P2^3;
  27          //////////////////////////////////////////////////////////
  28          sbit in1=P1^4;
  29          sbit in2=P1^5;
  30          sbit in3=P1^6;
  31          sbit in4=P1^7;
  32          sbit right=P3^0;
  33          sbit lift=P3^1;
  34          ////////////////////////////////////////////////////////////
  35          
  36          unsigned char code table[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,
  37                                  0xf8,0x80,0x90};
  38          
  39          
  40          /////////////////////////////////////////////////////////////////////////
  41          void delay1(unsigned int a)
  42          { 
  43   1      
  44   1      unsigned int i,j,k;
  45   1      for(i=a;i>0;i--)
  46   1          for(j=100;j>0;j--)
  47   1              for(k=100;k>0;k--);
  48   1      }
  49          /////////////////////////////////////////////////////////////////
  50          
  51          
  52          void delay2(unsigned int s)
  53          {
C51 COMPILER V9.01   SUIJICHAOSHENG                                                        08/25/2013 18:01:54 PAGE 2   

  54   1              unsigned int i;
  55   1              for(i=0; i<s; i++);
  56   1      
  57   1      }
  58          
  59          /********************************************************/
  60                                   //扫描数码管
  61          
  62           void Display(unsigned long x)
  63          {
  64   1        
  65   1      p2_0=0;p2_1=1;p2_2=1;p2_3=1;
  66   1      P0 =table[x/100%10];
  67   1      delay2(5);
  68   1      
  69   1      
  70   1      p2_0=1;p2_1=0;p2_2=1;p2_3=1;
  71   1      P0 =table[x/10%10];
  72   1      delay2(5);
  73   1      
  74   1      p2_0=1;p2_1=1;p2_2=0;p2_3=1;
  75   1      P0 =table[x%10];
  76   1      delay2(5);
  77   1      
  78   1      p2_0=1;p2_1=1;p2_2=1;p2_3=0;
  79   1      P0 =table[x/1000%10];
  80   1      delay2(5);
  81   1      
  82   1      p2_3=1;
  83   1      delay2(2);
  84   1      }
  85                          //关闭个位数码管
  86                  
  87          
  88          /********************************************************/
  89              void Conut(void)
  90                  {
  91   1               time=TH0*256+TL0;
  92   1               TH0=0;
  93   1               TL0=0;
  94   1              
  95   1               S=(time*1.7)/100;     //算出来是CM
  96   1               if((S>=400)||flag==1) //超出测量范围显示“-”
  97   1               {       
  98   2                flag=0;
  99   2                S=500;
 100   2               }
 101   1               }
 102          /********************************************************/
 103          ////////////////////////////////////////////////////////////////////////////////////////////////////////
 104          //小于距离是
 105          void juli(unsigned int x)       //x为小车转弯距离单位厘米
 106          {
 107   1      unsigned int a;
 108   1      unsigned int b;
 109   1      unsigned int c;
 110   1      unsigned int t=0;
 111   1      //////////////////////////////////////////////////////////////////////////////////////////////////////////
 112   1      // 距离大于是
 113   1      
 114   1      
 115   1          while(S<x)
C51 COMPILER V9.01   SUIJICHAOSHENG                                                        08/25/2013 18:01:54 PAGE 3   

 116   1              
 117   1              
 118   1              {
 119   2      ///////////////////////////////////////////////////////////////
 120   2               
 121   2      //         srand(t);
 122   2      //         a=((char)rand())%10;
 123   2      //         b=(a+1)%2; 
 124   2      //         c=a%2;  
 125   2               right=0;
 126   2                       lift=0;
 127   2                       delay1(5);
 128   2                       right=1;
 129   2                       lift=1;
 130   2                       in1=b;
 131   2                       in2=c;
 132   2                       in3=b;
 133   2                   in4=c;
 134   2                       
 135   2      
 136   2      
 137   2      ////////////////////////////////////////////////////////////////////
 138   2              
 139   2               while(!RX);            //当RX为零时等待
 140   2               TR0=1;                     //开启计数
 141   2               while(RX);                     //当RX为1计数并等待
 142   2               TR0=0;                         //关闭计数
 143   2           Conut();                   //计算
 144   2      //     P1=0X00;
 145   2           delay2(10000);
 146   2      //     P1=0X09;
 147   2           
 148   2           
 149   2           }
 150   1      
 151   1      
 152   1      
 153   1      
 154   1      ////////////////////////////////////////////////////////////////////////////////////////////////////////
 155   1       while(S>=x)
 156   1              {
 157   2              //产生随机数
 158   2              //////////////////////////////////////////////////////
 159   2          srand(t);
 160   2          a=((char)rand())%10;
 161   2          b=(a+1)%2; 
 162   2          c=a%2;
 163   2          t++;
 164   2          if(t==100){t=0;}
 165   2              ///////////////////////////////////  
 166   2              ////////////////////////////////////////////////
 167   2              right=1;
 168   2              lift=1;
 169   2              in1=1;
 170   2              in2=0;
 171   2              in3=0;
 172   2              in4=1;
 173   2              //////////////////////////////////////////////////////
 174   2               while(!RX);            //当RX为零时等待
 175   2               TR0=1;                     //开启计数
 176   2               while(RX);                     //当RX为1计数并等待
 177   2               TR0=0;                         //关闭计数
C51 COMPILER V9.01   SUIJICHAOSHENG                                                        08/25/2013 18:01:54 PAGE 4   

 178   2           Conut();                   //计算
 179   2      //     P1=0X00;
 180   2           delay2(10000);
 181   2      //     P1=0X0B;
 182   2       
 183   2           }
 184   1      
 185   1      
 186   1      }
 187          
 188          
 189          
 190          
 191          
 192               void zd0() interrupt 1              //T0中断用来计数器溢出,超过测距范围
 193            {
 194   1         // TH0=0;
 195   1         // TL0=0;
 196   1          flag=1;
 197   1              
 198   1                                                                       //中断溢出标志
 199   1        }
 200          /********************************************************/
 201             void  zd3()  interrupt 3              //T1中断用来扫描数码管和计800MS启动模块
 202            {
 203   1          ///////////////////////////////
 204   1              
 205   1               TH1=0x75;
 206   1               TL1=0x30;
 207   1               Display(S);
 208   1               timer++;
 209   1               if(timer>=10)
 210   1               {
 211   2                timer=0;
 212   2                TX=1;                                 //800MS  启动一次模块
 213   2       
 214   2                _nop_(); 
 215   2                _nop_(); 
 216   2                _nop_(); 
 217   2                _nop_(); 
 218   2                _nop_(); 
 219   2                _nop_(); 
 220   2                _nop_(); 
 221   2                _nop_(); 
 222   2                _nop_(); 
 223   2                _nop_();
 224   2                _nop_(); 
 225   2                _nop_(); 
 226   2                _nop_(); 
 227   2                _nop_();
 228   2      
 229   2                TX=0;
 230   2      
 231   2               } 
 232   1        }
 233          /*********************************************************/
 234          void  main(  void  )
 235          { 
 236   1         TMOD=0x11;              //设T0为方式1，GATE=1；
 237   1              TH0=0;
 238   1              TL0=0;          
 239   1              TH1=0x75;                  //2MS定时
C51 COMPILER V9.01   SUIJICHAOSHENG                                                        08/25/2013 18:01:54 PAGE 5   

 240   1              TL1=0x30;
 241   1              ET0=1;              //允许T0中断
 242   1              ET1=1;                     //允许T1中断
 243   1              TR1=1;                     //开启定时器
 244   1              EA=1;                      //开启总中断
 245   1      while(1)
 246   1      { 
 247   2      /////////////////////////////////////////////////////////////////
 248   2      /*   right=1;
 249   2              lift=1;
 250   2              in1=1;
 251   2              in2=0;
 252   2              in3=0;
 253   2              in4=1;    */
 254   2      //////////////////////////////////////////////////////////////
 255   2        
 256   2       //   ena=1;
 257   2       //   enb=1;
 258   2       //   P1=0X00;
 259   2          
 260   2       juli(25);
 261   2       
 262   2      
 263   2       }
 264   1       }               


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    652    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      9      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
